{"version":3,"sources":["../../src/LbdService.ts"],"names":["namedNode","literal","defaultGraph","quad","variable","DataFactory","LbdService","verbose","constructor","session","fetch","accessService","AccessService","dataService","DataService","store","Store","query","q","sources","registries","asStream","mutateQuery","myEngine","QueryEngine","inference","context","result","data","resultToString","JSON","parse","findLowerLevel","obj","variables","type","bgp","input","Promise","resolve","reject","OWL","sameAs","LBD","hasReference","hasIdentifier","quadStream","queryQuads","on","res","addQuad","subject","id","replaceAll","predicate","value","object","translation","usedVariables","Set","aliasNumber","aliases","pattern","patterns","item","Object","keys","termType","has","newVName","push","newV","add","forEach","alias","newPattern","Array","from","validateWebId","webId","info","isLoggedIn","Error","lbdLoc","getProjectRegistry","length","getAllProjects","aggregator","headers","Accept","then","t","json","myProjects","LDP","contains","map","i","stakeholder","hasProjectRegistry","location","bindings","bind","get","catch","err","undefined","getInbox","inbox","createProjectRegistry","url","publiclyAccessible","replace","q0","sparqlUpdate","q1","Aggregator","accessRights","actor","read","append","write","control","setResourceAccess","ResourceType","CONTAINER","error","console","log","removeProjectRegistry","deleteContainer"],"mappings":"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","sourcesContent":["import AccessService from \"./helpers/access-service\";\r\nimport DataService from \"./helpers/data-service\";\r\nimport { computeChecksumMd5 } from \"./helpers/utils\";\r\nimport { newEngine, IQueryResultBindings } from \"@comunica/actor-init-sparql\";\r\n// Import from \"@inrupt/solid-client\"\r\nimport {\r\n  createSolidDataset,\r\n  buildThing,\r\n  getSolidDataset,\r\n  createThing,\r\n  setThing,\r\n  setUrl,\r\n  addUrl,\r\n  getThingAll,\r\n  getUrlAll,\r\n  setDatetime,\r\n  saveSolidDatasetAt,\r\n} from \"@inrupt/solid-client\";\r\nimport { extract, streamToString } from \"./helpers/functions\";\r\nimport { RDF, SCHEMA_INRUPT, DCAT, OWL, LDP, AS, XSD, FOAF, DCTERMS } from \"@inrupt/vocab-common-rdf\";\r\nimport LBD from \"./helpers/vocab/lbds\";\r\nimport { AccessRights, ResourceType } from \"./helpers/BaseDefinitions\";\r\nimport { Session as BrowserSession } from \"@inrupt/solid-client-authn-browser\";\r\nimport { Session as NodeSession } from \"@inrupt/solid-client-authn-node\";\r\nimport { translate, toSparql } from 'sparqlalgebrajs'\r\nimport { Store, DataFactory } from 'n3'\r\nimport { QueryEngine } from \"@comunica/query-sparql\";\r\n\r\nconst { namedNode, literal, defaultGraph, quad, variable } = DataFactory;\r\n\r\nexport class LbdService {\r\n  public fetch;\r\n  public verbose: boolean = false;\r\n  public accessService: AccessService;\r\n  public dataService: DataService;\r\n  private session: BrowserSession | NodeSession;\r\n  private store: Store\r\n\r\n\r\n  /**\r\n   * \r\n   * @param session an (authenticated) session\r\n   * @param verbose optional parameter for logging purposes\r\n   */\r\n  constructor(session: BrowserSession | NodeSession, verbose: boolean = false) {\r\n    this.session = session;\r\n    this.fetch = session.fetch;\r\n    this.verbose = verbose;\r\n    this.accessService = new AccessService(session.fetch);\r\n    this.dataService = new DataService(session.fetch);\r\n    this.store = new Store()\r\n  }\r\n\r\n  /////////////////////////////////////////////////////////\r\n  ////////////////////// QUERY ////////////////////////////\r\n  /////////////////////////////////////////////////////////\r\n\r\n  public async query(q: string, { sources, registries, asStream }) {\r\n    const { query } = this.mutateQuery(q)\r\n\r\n    const myEngine = new QueryEngine();\r\n\r\n    await this.inference(myEngine, registries)\r\n    const context: any = { sources: [...sources, this.store], fetch }\r\n    const result = await myEngine.query(query, context)\r\n    const { data } = await myEngine.resultToString(result,\r\n      'application/sparql-results+json');\r\n    if (asStream) {\r\n      return data\r\n    } else {\r\n      return JSON.parse(await streamToString(data))\r\n    }\r\n  }\r\n\r\n  private findLowerLevel(obj, variables) {\r\n    if (!variables) variables = obj.variables\r\n    if (obj.type === \"bgp\") {\r\n      return { bgp: obj, variables }\r\n    } else {\r\n      return this.findLowerLevel(obj.input, variables)\r\n    }\r\n  }\r\n\r\n  private inference(myEngine, registries): Promise<void> {\r\n    return new Promise(async (resolve, reject) => {\r\n      const q = `\r\n      CONSTRUCT {\r\n       ?s1 <${OWL.sameAs}> ?s2 .\r\n       ?s2 <${OWL.sameAs}> ?s1 .\r\n      } WHERE {\r\n          ?concept1 <${LBD.hasReference}>/<${LBD.hasIdentifier}>/<http://schema.org/value> ?s1 .\r\n          ?concept2 <${LBD.hasReference}>/<${LBD.hasIdentifier}>/<http://schema.org/value> ?s2 .\r\n          ?concept1 <${OWL.sameAs}> ?concept2 .\r\n      }`\r\n      const quadStream = await myEngine.queryQuads(q, {\r\n        sources: registries,\r\n        fetch\r\n      });\r\n\r\n      quadStream.on('data', (res) => {\r\n        this.store.addQuad(quad(\r\n          namedNode(res.subject.id.replaceAll('\"', '')),\r\n          namedNode(res.predicate.value),\r\n          namedNode(res.object.id.replaceAll('\"', '')),\r\n          defaultGraph()\r\n        ))\r\n      });\r\n\r\n      quadStream.on('end', () => {\r\n        resolve()\r\n      })\r\n    })\r\n  }\r\n\r\n  private mutateQuery(query) {\r\n    const translation = translate(query);\r\n    const { bgp, variables } = this.findLowerLevel(translation, translation.variables)\r\n    const usedVariables = new Set()\r\n    let aliasNumber = 1\r\n    let aliases = {}\r\n    for (const pattern of bgp.patterns) {\r\n      for (const item of Object.keys(pattern)) {\r\n        if (pattern[item].termType === \"Variable\") {\r\n          if (usedVariables.has(pattern[item])) {\r\n            const newVName = `${pattern[item].value}_alias${aliasNumber}`\r\n            if (!aliases[pattern[item].value]) aliases[pattern[item].value] = []\r\n\r\n            aliases[pattern[item].value].push(newVName)\r\n            aliasNumber += 1\r\n            const newV = { termType: \"Variable\", value: newVName }\r\n            pattern[item] = newV\r\n          }\r\n          usedVariables.add(pattern[item])\r\n        }\r\n\r\n      }\r\n    }\r\n    Object.keys(aliases).forEach(item => {\r\n      aliases[item].forEach(alias => {\r\n        const newPattern = quad(\r\n          variable(item),\r\n          namedNode(\"http://www.w3.org/2002/07/owl#sameAs\"),\r\n          variable(alias),\r\n          defaultGraph()\r\n        )\r\n        bgp.patterns.push(newPattern)\r\n      })\r\n    })\r\n    const q: any = { type: \"project\", input: { type: \"bgp\", patterns: bgp.patterns }, variables: Array.from(usedVariables) }\r\n    return { query: toSparql(q), variables: Array.from(usedVariables) }\r\n  }\r\n\r\n\r\n  /////////////////////////////////////////////////////////\r\n  ////////////////////// PREPARATION //////////////////////\r\n  /////////////////////////////////////////////////////////\r\n  /**\r\n   * @description This function checks if the card (webId) contains a lbds:hasProjectRegistry pointer\r\n   * @param webId the webId/card to check\r\n   * @returns boolean - false: the WebID doesn't have a project registry yet / true: a project registry is mentioned in the card\r\n   */\r\n  public async validateWebId(webId?: string) {\r\n    if (!webId) { if (this.session.info.isLoggedIn) { webId = this.session.info.webId } else { throw new Error('No WebID found') } }\r\n\r\n    const lbdLoc = await this.getProjectRegistry(webId);\r\n    if (lbdLoc && lbdLoc.length > 0) {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * @description This function retrieves the LBDserver projects from a project aggregator (e.g. a project registry or public aggregator)\r\n   * @param aggregator an LBDS aggregator, aggregating projects with lbds:aggregates\r\n   * @returns Array of LBDserver project access points (URL).\r\n   */\r\n  public async getAllProjects(aggregator) {\r\n    const data = await this.fetch(aggregator, {\r\n      headers: { Accept: \"application/ld+json\" },\r\n    }).then((t) => t.json());\r\n    const myProjects = extract(data, aggregator)[LDP.contains].map(\r\n      (i) => i[\"@id\"]\r\n    );\r\n    return myProjects;\r\n  }\r\n\r\n  /**\r\n   * @description Find the LBDserver project registry of a specific stakeholder by their WebID.\r\n   * @param stakeholder The WebID of the stakeholder from whom the project registry should be retrieved\r\n   * @returns URL of project registry\r\n   */\r\n  public async getProjectRegistry(\r\n    stakeholder?: string\r\n  ): Promise<string | undefined> {\r\n    if (!stakeholder) { if (this.session.info.isLoggedIn) { stakeholder = this.session.info.webId } else { throw new Error('No WebID found') } }\r\n    const myEngine = newEngine();\r\n    const q = `select ?loc where {<${stakeholder}> <${LBD.hasProjectRegistry}> ?loc}`;\r\n    const location = await myEngine\r\n      .query(q, { sources: [stakeholder], fetch: this.fetch })\r\n      .then((res: IQueryResultBindings) => res.bindings())\r\n      .then((bind: any) => bind.map((i) => i.get(\"?loc\").value))\r\n      .catch((err: Error) => {\r\n        throw err;\r\n      });\r\n    if (location && location.length > 0) {\r\n      return location[0];\r\n    } else {\r\n      return undefined;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @description This function retrieves the LDP inbox from a particular WebID\r\n   * @param stakeholder The WebID of the stakeholder from whom the LDP inbox should be retrieved\r\n   * @returns The inbox URL\r\n   */\r\n  public async getInbox(stakeholder: string): Promise<string | undefined> {\r\n    const myEngine = newEngine();\r\n    const q = `select ?inbox where {<${stakeholder}> <${LDP.inbox}> ?inbox}`;\r\n    const inbox = await myEngine\r\n      .query(q, { sources: [stakeholder], fetch: this.fetch })\r\n      .then((res: IQueryResultBindings) => res.bindings())\r\n      .then((bind: any) => bind.map((i) => i.get(\"?inbox\").value))\r\n      .catch((err: Error) => {\r\n        throw err;\r\n      });\r\n    if (inbox && inbox.length > 0) {\r\n      return inbox[0];\r\n    } else {\r\n      return undefined;\r\n    }\r\n  }\r\n\r\n  //   public async inviteStakeholder(stakeholder: string, projectId: string) {\r\n  //     const inbox = await this.getInbox(stakeholder);\r\n  //     const id = v4();\r\n  //     const url = inbox + id;\r\n  //     const message = `<>\r\n  //   a <${AS.Announce}> ;\r\n  //   <${AS.actor}> <${this.session.info.webId}> ;\r\n  //   <${AS.object}> <#invite> ;\r\n  //   <${AS.target}> <${stakeholder}> ;\r\n  //   <${AS.updated}> \"${new Date().toISOString()}\"^^${XSD.dateTime} .\r\n\r\n  // <#invite> a ${LBD.ProjectInvite}; \r\n  //   <${FOAF.primaryTopic}> <#project> .\r\n  // <#project> a <${LBD.Project}> ;\r\n  //     <${DCTERMS.identifier} \"${projectId}\" .\r\n  //   `;\r\n\r\n  //   const options = {\r\n  //     method: \"POST\",\r\n  //     body: message,\r\n  //   }\r\n  //     // await this.session.fetch()\r\n  //   }\r\n\r\n  /**\r\n   * @description Create an LBDserver project registry\r\n   * @param url Where the project registry should be created\r\n   * @param publiclyAccessible Access rights for the project registry\r\n   * @returns the URL of the LBDserver Project Registry\r\n   */\r\n  public async createProjectRegistry(\r\n    url: string = undefined,\r\n    publiclyAccessible: boolean = true\r\n  ): Promise<string> {\r\n    try {\r\n      const stakeholder = this.session.info.webId\r\n      if (!url) url = stakeholder.replace(\"/profile/card#me\", \"/lbd/\");\r\n\r\n      const q0 = `INSERT DATA {\r\n          <${stakeholder}> <${LBD.hasProjectRegistry}> <${url}> .\r\n        }`;\r\n      await this.dataService.sparqlUpdate(stakeholder, q0);\r\n\r\n      // create the LBD registry (container / Aggregator)\r\n      const q1 = `INSERT DATA {\r\n        <${url}> a <${LBD.Aggregator}> .\r\n      }`;\r\n\r\n      // the updates immediately creates the container\r\n      await this.dataService.sparqlUpdate(url, q1);\r\n\r\n      let accessRights: AccessRights;\r\n      let actor: string | undefined;\r\n      if (publiclyAccessible) {\r\n        accessRights = {\r\n          read: true,\r\n          append: false,\r\n          write: false,\r\n          control: false,\r\n        };\r\n      } else {\r\n        accessRights = { read: true, append: true, write: true, control: true };\r\n        actor = stakeholder;\r\n      }\r\n      await this.accessService.setResourceAccess(\r\n        url,\r\n        accessRights,\r\n        ResourceType.CONTAINER,\r\n        actor\r\n      );\r\n      return url;\r\n    } catch (error) {\r\n      console.log(`error`, error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @description delete a project registry at a particular location\r\n   * @param stakeholder The stakeholder (the authenticated agent)\r\n   * @param url The URL of the project registry\r\n   */\r\n  public async removeProjectRegistry(url: string) {\r\n    try {\r\n      const q0 = `DELETE {<${this.session.info.webId}> <${LBD.hasProjectRegistry}> <${url}> .}\r\n      WHERE {<${this.session.info.webId}> <${LBD.hasProjectRegistry}> ?reg .}`;\r\n      await this.dataService.sparqlUpdate(this.session.info.webId, q0);\r\n      await this.dataService.deleteContainer(url, true);\r\n    } catch (error) {\r\n      console.log(`error`, error);\r\n      throw error;\r\n    }\r\n  }\r\n}\r\n"],"file":"LbdService.js"}