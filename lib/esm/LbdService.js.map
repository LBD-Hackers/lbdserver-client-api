{"version":3,"sources":["../../src/LbdService.ts"],"names":["namedNode","literal","defaultGraph","quad","variable","DataFactory","LbdService","verbose","constructor","session","fetch","accessService","AccessService","dataService","DataService","store","Store","validateWebId","webId","info","isLoggedIn","Error","lbdLoc","getProjectRegistry","length","getAllProjects","aggregator","data","headers","Accept","then","t","json","myProjects","LDP","contains","map","i","stakeholder","queryEngine","QueryEngine","q","LBD","hasProjectRegistry","location","queryBindings","sources","res","toArray","bind","get","value","catch","err","undefined","getInbox","inbox","createProjectRegistry","url","publiclyAccessible","replace","q0","sparqlUpdate","q1","Aggregator","accessRights","actor","read","append","write","control","setResourceAccess","ResourceType","CONTAINER","error","console","log","removeProjectRegistry","deleteContainer"],"mappings":"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","sourcesContent":["import AccessService from \"./helpers/access-service\";\r\nimport DataService from \"./helpers/data-service\";\r\nimport { computeChecksumMd5 } from \"./helpers/utils\";\r\nimport { newEngine, IQueryResultBindings } from \"@comunica/actor-init-sparql\";\r\n// Import from \"@inrupt/solid-client\"\r\nimport {\r\n  createSolidDataset,\r\n  buildThing,\r\n  getSolidDataset,\r\n  createThing,\r\n  setThing,\r\n  setUrl,\r\n  addUrl,\r\n  getThingAll,\r\n  getUrlAll,\r\n  setDatetime,\r\n  saveSolidDatasetAt,\r\n} from \"@inrupt/solid-client\";\r\nimport { extract, streamToString } from \"./helpers/functions\";\r\nimport { RDF, SCHEMA_INRUPT, DCAT, OWL, LDP, AS, XSD, FOAF, DCTERMS } from \"@inrupt/vocab-common-rdf\";\r\nimport LBD from \"./helpers/vocab/lbds\";\r\nimport { AccessRights, ResourceType } from \"./helpers/BaseDefinitions\";\r\nimport { Session as BrowserSession } from \"@inrupt/solid-client-authn-browser\";\r\nimport { Session as NodeSession } from \"@inrupt/solid-client-authn-node\";\r\nimport { translate, toSparql } from 'sparqlalgebrajs'\r\nimport { Store, DataFactory } from 'n3'\r\nimport { QueryEngine } from \"@comunica/query-sparql\";\r\n\r\nconst { namedNode, literal, defaultGraph, quad, variable } = DataFactory;\r\n\r\nexport class LbdService {\r\n  public fetch;\r\n  public verbose: boolean = false;\r\n  public accessService: AccessService;\r\n  public dataService: DataService;\r\n  private session: BrowserSession | NodeSession;\r\n  private store: Store\r\n\r\n\r\n  /**\r\n   * \r\n   * @param session an (authenticated) session\r\n   * @param verbose optional parameter for logging purposes\r\n   */\r\n  constructor(session: BrowserSession | NodeSession, verbose: boolean = false) {\r\n    this.session = session;\r\n    this.fetch = session.fetch;\r\n    this.verbose = verbose;\r\n    this.accessService = new AccessService(session.fetch);\r\n    this.dataService = new DataService(session.fetch);\r\n    this.store = new Store()\r\n  }\r\n\r\n  /////////////////////////////////////////////////////////\r\n  ////////////////////// QUERY ////////////////////////////\r\n  /////////////////////////////////////////////////////////\r\n\r\n  // public async query(q: string, { sources, registries, asStream, queryEngine }) {\r\n  //   const { query } = this.mutateQuery(q)\r\n\r\n  //   const myEngine = new QueryEngine();\r\n\r\n  //   await this.inference(myEngine, registries)\r\n  //   const context: any = { sources: [...sources, this.store], fetch }\r\n  //   const result = await myEngine.query(query, context)\r\n  //   const { data } = await myEngine.resultToString(result,\r\n  //     'application/sparql-results+json');\r\n  //   if (asStream) {\r\n  //     return data\r\n  //   } else {\r\n  //     return JSON.parse(await streamToString(data))\r\n  //   }\r\n  // }\r\n\r\n  // private findLowerLevel(obj, variables) {\r\n  //   if (!variables) variables = obj.variables\r\n  //   if (obj.type === \"bgp\") {\r\n  //     return { bgp: obj, variables }\r\n  //   } else {\r\n  //     return this.findLowerLevel(obj.input, variables)\r\n  //   }\r\n  // }\r\n\r\n  // private inference(myEngine, registries): Promise<void> {\r\n  //   return new Promise(async (resolve, reject) => {\r\n  //     const q = `\r\n  //     CONSTRUCT {\r\n  //      ?s1 <${OWL.sameAs}> ?s2 .\r\n  //      ?s2 <${OWL.sameAs}> ?s1 .\r\n  //     } WHERE {\r\n  //         ?concept1 <${LBD.hasReference}>/<${LBD.hasIdentifier}>/<https://w3id.org/lbdserver#value> ?s1 .\r\n  //         ?concept2 <${LBD.hasReference}>/<${LBD.hasIdentifier}>/<https://w3id.org/lbdserver#value> ?s2 .\r\n  //         ?concept1 <${OWL.sameAs}> ?concept2 .\r\n  //     }`\r\n  //     const quadStream = await myEngine.queryQuads(q, {\r\n  //       sources: registries,\r\n  //       fetch\r\n  //     });\r\n\r\n  //     quadStream.on('data', (res) => {\r\n  //       this.store.addQuad(quad(\r\n  //         namedNode(res.subject.id.replaceAll('\"', '')),\r\n  //         namedNode(res.predicate.value),\r\n  //         namedNode(res.object.id.replaceAll('\"', '')),\r\n  //         defaultGraph()\r\n  //       ))\r\n  //     });\r\n\r\n  //     quadStream.on('end', () => {\r\n  //       resolve()\r\n  //     })\r\n  //   })\r\n  // }\r\n\r\n  // private mutateQuery(query) {\r\n  //   const translation = translate(query);\r\n  //   const { bgp, variables } = this.findLowerLevel(translation, translation.variables)\r\n  //   const usedVariables = new Set()\r\n  //   let aliasNumber = 1\r\n  //   let aliases = {}\r\n  //   for (const pattern of bgp.patterns) {\r\n  //     for (const item of Object.keys(pattern)) {\r\n  //       if (pattern[item].termType === \"Variable\") {\r\n  //         if (usedVariables.has(pattern[item])) {\r\n  //           const newVName = `${pattern[item].value}_alias${aliasNumber}`\r\n  //           if (!aliases[pattern[item].value]) aliases[pattern[item].value] = []\r\n\r\n  //           aliases[pattern[item].value].push(newVName)\r\n  //           aliasNumber += 1\r\n  //           const newV = { termType: \"Variable\", value: newVName }\r\n  //           pattern[item] = newV\r\n  //         }\r\n  //         usedVariables.add(pattern[item])\r\n  //       }\r\n\r\n  //     }\r\n  //   }\r\n  //   Object.keys(aliases).forEach(item => {\r\n  //     aliases[item].forEach(alias => {\r\n  //       const newPattern = quad(\r\n  //         variable(item),\r\n  //         namedNode(\"http://www.w3.org/2002/07/owl#sameAs\"),\r\n  //         variable(alias),\r\n  //         defaultGraph()\r\n  //       )\r\n  //       bgp.patterns.push(newPattern)\r\n  //     })\r\n  //   })\r\n  //   const q: any = { type: \"project\", input: { type: \"bgp\", patterns: bgp.patterns }, variables: Array.from(usedVariables) }\r\n  //   return { query: toSparql(q), variables: Array.from(usedVariables) }\r\n  // }\r\n\r\n\r\n  /////////////////////////////////////////////////////////\r\n  ////////////////////// PREPARATION //////////////////////\r\n  /////////////////////////////////////////////////////////\r\n  /**\r\n   * @description This function checks if the card (webId) contains a lbds:hasProjectRegistry pointer\r\n   * @param webId the webId/card to check\r\n   * @returns boolean - false: the WebID doesn't have a project registry yet / true: a project registry is mentioned in the card\r\n   */\r\n  public async validateWebId(webId?: string) {\r\n    if (!webId) { if (this.session.info.isLoggedIn) { webId = this.session.info.webId } else { throw new Error('No WebID found') } }\r\n\r\n    const lbdLoc = await this.getProjectRegistry(webId);\r\n    if (lbdLoc && lbdLoc.length > 0) {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * @description This function retrieves the LBDserver projects from a project aggregator (e.g. a project registry or public aggregator)\r\n   * @param aggregator an LBDS aggregator, aggregating projects with lbds:aggregates\r\n   * @returns Array of LBDserver project access points (URL).\r\n   */\r\n  public async getAllProjects(aggregator) {\r\n    const data = await this.fetch(aggregator, {\r\n      headers: { Accept: \"application/ld+json\" },\r\n    }).then((t) => t.json());\r\n    const myProjects = extract(data, aggregator)[LDP.contains].map(\r\n      (i) => i[\"@id\"]\r\n    );\r\n    return myProjects;\r\n  }\r\n\r\n  /**\r\n   * @description Find the LBDserver project registry of a specific stakeholder by their WebID.\r\n   * @param stakeholder The WebID of the stakeholder from whom the project registry should be retrieved\r\n   * @returns URL of project registry\r\n   */\r\n  public async getProjectRegistry(\r\n    stakeholder?: string,\r\n    queryEngine: QueryEngine = new QueryEngine()\r\n  ): Promise<string | undefined> {\r\n    if (!stakeholder) { if (this.session.info.isLoggedIn) { stakeholder = this.session.info.webId } else { throw new Error('No WebID found') } }\r\n    const q = `select ?loc where {<${stakeholder}> <${LBD.hasProjectRegistry}> ?loc}`;\r\n    const location = await queryEngine\r\n      .queryBindings(q, { sources: [stakeholder], fetch: this.fetch })\r\n      .then((res) => res.toArray())\r\n      .then((bind: any) => bind.map((i) => i.get(\"loc\").value))\r\n      .catch((err: Error) => {\r\n        throw err;\r\n      });\r\n    if (location && location.length > 0) {\r\n      return location[0];\r\n    } else {\r\n      return undefined;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @description This function retrieves the LDP inbox from a particular WebID\r\n   * @param stakeholder The WebID of the stakeholder from whom the LDP inbox should be retrieved\r\n   * @returns The inbox URL\r\n   */\r\n  public async getInbox(stakeholder: string, queryEngine: QueryEngine = new QueryEngine()): Promise<string | undefined> {\r\n    const q = `select ?inbox where {<${stakeholder}> <${LDP.inbox}> ?inbox}`;\r\n    const inbox = await queryEngine\r\n      .queryBindings(q, { sources: [stakeholder], fetch: this.fetch })\r\n      .then((res) => res.toArray())\r\n      .then((bind: any) => bind.map((i) => i.get(\"inbox\").value))\r\n      .catch((err: Error) => {\r\n        throw err;\r\n      });\r\n    if (inbox && inbox.length > 0) {\r\n      return inbox[0];\r\n    } else {\r\n      return undefined;\r\n    }\r\n  }\r\n\r\n  //   public async inviteStakeholder(stakeholder: string, projectId: string) {\r\n  //     const inbox = await this.getInbox(stakeholder);\r\n  //     const id = v4();\r\n  //     const url = inbox + id;\r\n  //     const message = `<>\r\n  //   a <${AS.Announce}> ;\r\n  //   <${AS.actor}> <${this.session.info.webId}> ;\r\n  //   <${AS.object}> <#invite> ;\r\n  //   <${AS.target}> <${stakeholder}> ;\r\n  //   <${AS.updated}> \"${new Date().toISOString()}\"^^${XSD.dateTime} .\r\n\r\n  // <#invite> a ${LBD.ProjectInvite}; \r\n  //   <${FOAF.primaryTopic}> <#project> .\r\n  // <#project> a <${LBD.Project}> ;\r\n  //     <${DCTERMS.identifier} \"${projectId}\" .\r\n  //   `;\r\n\r\n  //   const options = {\r\n  //     method: \"POST\",\r\n  //     body: message,\r\n  //   }\r\n  //     // await this.session.fetch()\r\n  //   }\r\n\r\n  /**\r\n   * @description Create an LBDserver project registry\r\n   * @param url Where the project registry should be created\r\n   * @param publiclyAccessible Access rights for the project registry\r\n   * @returns the URL of the LBDserver Project Registry\r\n   */\r\n  public async createProjectRegistry(\r\n    url: string = undefined,\r\n    publiclyAccessible: boolean = true\r\n  ): Promise<string> {\r\n    try {\r\n      const stakeholder = this.session.info.webId\r\n      if (!url) url = stakeholder.replace(\"/profile/card#me\", \"/lbd/\");\r\n\r\n      const q0 = `INSERT DATA {\r\n          <${stakeholder}> <${LBD.hasProjectRegistry}> <${url}> .\r\n        }`;\r\n      await this.dataService.sparqlUpdate(stakeholder, q0);\r\n\r\n      // create the LBD registry (container / Aggregator)\r\n      const q1 = `INSERT DATA {\r\n        <${url}> a <${LBD.Aggregator}> .\r\n      }`;\r\n\r\n      // the updates immediately creates the container\r\n      await this.dataService.sparqlUpdate(url, q1);\r\n\r\n      let accessRights: AccessRights;\r\n      let actor: string | undefined;\r\n      if (publiclyAccessible) {\r\n        accessRights = {\r\n          read: true,\r\n          append: false,\r\n          write: false,\r\n          control: false,\r\n        };\r\n      } else {\r\n        accessRights = { read: true, append: true, write: true, control: true };\r\n        actor = stakeholder;\r\n      }\r\n      await this.accessService.setResourceAccess(\r\n        url,\r\n        accessRights,\r\n        ResourceType.CONTAINER,\r\n        actor\r\n      );\r\n      return url;\r\n    } catch (error) {\r\n      console.log(`error`, error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @description delete a project registry at a particular location\r\n   * @param stakeholder The stakeholder (the authenticated agent)\r\n   * @param url The URL of the project registry\r\n   */\r\n  public async removeProjectRegistry(url: string) {\r\n    try {\r\n      const q0 = `DELETE {<${this.session.info.webId}> <${LBD.hasProjectRegistry}> <${url}> .}\r\n      WHERE {<${this.session.info.webId}> <${LBD.hasProjectRegistry}> ?reg .}`;\r\n      await this.dataService.sparqlUpdate(this.session.info.webId, q0);\r\n      await this.dataService.deleteContainer(url, true);\r\n    } catch (error) {\r\n      console.log(`error`, error);\r\n      throw error;\r\n    }\r\n  }\r\n}\r\n"],"file":"LbdService.js"}