{"version":3,"file":"LbdDataset.js","names":["LbdDataset","constructor","session","url","fetch","accessService","AccessService","dataService","DataService","lbdService","LbdService","checkExistence","status","method","then","result","create","options","makePublic","datasetUrl","datasetArr","split","datasetId","length","res","createContainer","aclDefault","ACL","default","Authorization","agentClass","FOAF","Agent","sparqlUpdate","undefined","deleteFile","q","DCAT","Dataset","DCTERMS","creator","info","webId","identifier","pop","datasetRegistry","join","q0","dataset","Object","keys","key","Array","isArray","forEach","item","t","startsWith","delete","deleteContainer","update","query","addDistribution","distribution","mimetype","distributionId","dist","LbdDistribution","getDistributions","queryEngine","QueryEngine","distributions","queryBindings","sources","i","toArray","map","get","value","id"],"sources":["../../src/LbdDataset.ts"],"sourcesContent":["import AccessService from \"./helpers/access-service\";\r\nimport DataService from \"./helpers/data-service\";\r\n\r\nimport LBD from \"./helpers/vocab/lbds\";\r\nimport { AccessRights, ResourceType } from \"./helpers/BaseDefinitions\";\r\nimport {LbdService} from \"./LbdService\";\r\nimport {extract} from \"./helpers/functions\"\r\nimport {v4} from \"uuid\"\r\nimport { ACL, DCAT, DCTERMS, FOAF, RDFS } from \"@inrupt/vocab-common-rdf\";\r\nimport {LbdDistribution} from './LbdDistribution'\r\nimport { Session as BrowserSession } from \"@inrupt/solid-client-authn-browser\";\r\nimport { Session as NodeSession} from \"@inrupt/solid-client-authn-node\";\r\nimport { QueryEngine } from \"@comunica/query-sparql\";\r\n\r\nexport class LbdDataset {\r\n  public fetch;\r\n  public accessService: AccessService;\r\n  public dataService: DataService;\r\n  public lbdService: LbdService;\r\n  public projectId: string;\r\n  public url: string;\r\n  public distributions: LbdDistribution[]\r\n  public data: object[];\r\n  public session: any\r\n\r\n  constructor(session: any, url: string) {\r\n    this.session = session\r\n    this.fetch = session.fetch;\r\n    this.url = url\r\n    this.accessService = new AccessService(session.fetch);\r\n    this.dataService = new DataService(session.fetch);\r\n    this.lbdService = new LbdService(session);\r\n  }\r\n\r\n  /**\r\n   * \r\n   * @returns boolean: this dataset exists or not\r\n   */\r\n  public async checkExistence() {\r\n    const status = await this.fetch(this.url, {method: \"HEAD\"}).then(result => result.status)\r\n    if (status === 200) {\r\n      return true\r\n    } else {\r\n      return false\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @description create this dataset within the active project\r\n   * @param options Optional - Object containing metadata about the dataset to be created. e.g: {[RDFS.label]: \"theLabel\"}\r\n   * @param makePublic initial access rights for the dataset (boolean)\r\n   */\r\n  public async create(\r\n    options: object = {},\r\n    makePublic?: boolean,\r\n  ) {\r\n    const datasetUrl = this.url\r\n    const datasetArr = this.url.split('/')\r\n    const datasetId = datasetArr[datasetArr.length - 2]\r\n    const status = await this.fetch(datasetUrl, {method: \"HEAD\"}).then(res => res.status)\r\n    if (status !== 200) {\r\n      await this.dataService.createContainer(datasetUrl, makePublic)\r\n\r\n      //workaround to allow inherited access rights\r\n\r\n      if (makePublic) {\r\n        let aclDefault = `INSERT {?rule <${ACL.default}> <${datasetUrl}>} WHERE {?rule a <${ACL.Authorization}> ; <${ACL.agentClass}> <${FOAF.Agent}>}`\r\n        await this.dataService.sparqlUpdate(datasetUrl + \".acl\", aclDefault)\r\n      }\r\n\r\n      if (makePublic === undefined) {\r\n        this.dataService.deleteFile(datasetUrl + \".acl\")\r\n      }\r\n    }\r\n\r\n    let q = `INSERT DATA {<${datasetUrl}> a <${DCAT.Dataset}> ; <${DCTERMS.creator}> <${this.session.info.webId}> ; <${DCTERMS.identifier}> \"${datasetId}\". }`\r\n\r\n    await this.dataService.sparqlUpdate(datasetUrl, q)\r\n\r\n    datasetArr.pop()\r\n    datasetArr.pop()\r\n    const datasetRegistry = datasetArr.join(\"/\") + \"/\"\r\n    let q0 = `INSERT DATA {<${datasetRegistry}> <${DCAT.dataset}> <${datasetUrl}> . }`\r\n\r\n    await this.dataService.sparqlUpdate(datasetRegistry, q0)\r\n\r\n    \r\n    if (Object.keys(options).length > 0) {\r\n      let q0 = `INSERT DATA { `\r\n      for (const key of Object.keys(options)) {\r\n        if (Array.isArray(options[key])) {\r\n          options[key].forEach((item :string) => {\r\n            let t\r\n            if (item.startsWith(\"http\")) {\r\n              t = `<${item}>`\r\n            } else {\r\n              t = `\"${item}\"`\r\n            }\r\n            q0 += `<${datasetUrl}> <${key}> ${t} .`\r\n          })\r\n        } else {\r\n          let t\r\n          if (options[key].startsWith(\"http\")) {\r\n            t = `<${options[key]}>`\r\n          } else {\r\n            t = `\"${options[key]}\"`\r\n          }\r\n          q0 += `<${datasetUrl}> <${key}> ${t} .`\r\n        }\r\n      }    \r\n      q0 += \"}\"\r\n      await this.dataService.sparqlUpdate(datasetUrl, q0)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @description delete this dataset\r\n   * @returns void\r\n   */\r\n  public async delete() {\r\n    await this.dataService.deleteContainer(this.url, true)\r\n    return\r\n  }\r\n\r\n  /**\r\n   * @description Update the dataset with SPARQL (dangerous - watch out!)\r\n   * @param query The SPARQL query with which to update the dataset\r\n   */\r\n  public async update(query) {\r\n      await this.dataService.sparqlUpdate(this.url, query)\r\n  }\r\n\r\n  /////////////////////////////////////////////////////////\r\n  //////////////////// DISTRIBUTIONS///////////////////////\r\n  /////////////////////////////////////////////////////////\r\n  /**\r\n   * @description create a distribution for this dataset\r\n   * @param distribution The file to upload as a dump of the dataset\r\n   * @param mimetype The mimetype of the distribution (if omitted it is guessed)\r\n   * @param options options (currently not implemented)\r\n   * @param distributionId the ID of the distribution - normally UUID, but can be overridden\r\n   * @param makePublic initial access rights for the dataset (boolean)\r\n   * @returns the distribution object\r\n   */\r\n  public async addDistribution(distribution: File | Buffer, mimetype? ,options: object = {}, distributionId: string = v4(), makePublic: boolean = false) {      \r\n    const dist = new LbdDistribution(this.session, this, distributionId)\r\n    await dist.create(distribution, {}, mimetype, makePublic)\r\n    return dist\r\n  }\r\n\r\n  /**\r\n   * @description get an Array of distribution URLs of this dataset\r\n   * @returns an Array of distribution URLs\r\n   */\r\n  public async getDistributions(queryEngine = new QueryEngine()) {\r\n      if (this.distributions) {\r\n        return this.distributions\r\n      }\r\n      else {\r\n        const q = `select ?dist where {?ds <${DCAT.distribution}> ?dist}`\r\n        const res: LbdDistribution[] = await queryEngine.queryBindings(q, {sources: [this.url], fetch: this.fetch})\r\n        .then(i => i.toArray())\r\n        .then(i => {\r\n          return i.map(item => {\r\n            const url = item.get('dist').value\r\n            const id = url.split('/')[url.split('/').length - 1]\r\n            const dist = new LbdDistribution(this.session, this, id)\r\n            return dist\r\n          })\r\n        })\r\n        this.distributions = res\r\n        return res\r\n      }      \r\n  }\r\n\r\n}\r\n\r\n"],"mappings":"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"}