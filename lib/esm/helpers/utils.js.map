{"version":3,"file":"utils.js","names":["computeChecksumMd5","file","Promise","resolve","reject","chunkSize","spark","SparkMD5","ArrayBuffer","fileReader","FileReader","cursor","onerror","processChunk","chunk_start","chunk_end","Math","min","size","readAsArrayBuffer","slice","onload","e","append","target","result","end","parseStream","stream","chunks","on","chunk","push","Buffer","from","err","console","log","JSON","parse","concat","toString","getQueryResult","source","property","fetch","single","queryEngine","QueryEngine","q","bindings","queryBindings","sources","then","i","toArray","get","value","map"],"sources":["../../../src/helpers/utils.ts"],"sourcesContent":["import * as SparkMD5 from 'spark-md5';\r\nimport { QueryEngine } from '@comunica/query-sparql';\r\n\r\nexport function computeChecksumMd5(file: File): Promise<string> {\r\n    return new Promise((resolve, reject) => {\r\n      const chunkSize = 5242880; // Read in chunks of 5MB\r\n      const spark = new SparkMD5.ArrayBuffer();\r\n      const fileReader = new FileReader();\r\n  \r\n      let cursor = 0; // current cursor in file\r\n  \r\n      fileReader.onerror = function(): void {\r\n        reject('MD5 computation failed - error reading the file');\r\n      };\r\n  \r\n      // read chunk starting at `cursor` into memory\r\n      function processChunk(chunk_start: number): void {\r\n        const chunk_end = Math.min(file.size, chunk_start + chunkSize);\r\n        \r\n        fileReader.readAsArrayBuffer(file.slice(chunk_start, chunk_end));\r\n      }\r\n  \r\n      // when it's available in memory, process it\r\n      // If using TS >= 3.6, you can use `FileReaderProgressEvent` type instead \r\n      // of `any` for `e` variable, otherwise stick with `any`\r\n      // See https://github.com/Microsoft/TypeScript/issues/25510\r\n      fileReader.onload = function(e: any): void {\r\n        spark.append(e.target.result); // Accumulate chunk to md5 computation\r\n        cursor += chunkSize; // Move past this chunk\r\n  \r\n        if (cursor < file.size) {\r\n          // Enqueue next chunk to be accumulated\r\n          processChunk(cursor);\r\n        } else {\r\n          // Computation ended, last chunk has been processed. Return as Promise value.\r\n          // This returns the base64 encoded md5 hash, which is what\r\n          // Rails ActiveStorage or cloud services expect\r\n          // resolve(btoa(spark.end(true)));\r\n  \r\n          // If you prefer the hexdigest form (looking like\r\n          // '7cf530335b8547945f1a48880bc421b2'), replace the above line with:\r\n          resolve(spark.end());\r\n        }\r\n      };\r\n  \r\n      processChunk(0);\r\n    });\r\n  }\r\n\r\nexport function parseStream(stream) {\r\n  const chunks = [];\r\n  return new Promise((resolve, reject) => {\r\n    stream.on(\"data\", (chunk) => chunks.push(Buffer.from(chunk)));\r\n    stream.on(\"error\", (err) => {console.log('err', err); reject(err)});\r\n    stream.on(\"end\", () =>{\r\n      resolve(JSON.parse(Buffer.concat(chunks).toString(\"utf8\")))\r\n    });\r\n  });\r\n}\r\n\r\nexport async function getQueryResult(source, property, fetch, single: boolean = false, queryEngine: QueryEngine = new QueryEngine()) {\r\n  const q = `SELECT ?res WHERE {<${source}> <${property}> ?res}`\r\n  const bindings = await queryEngine.queryBindings(q, {sources: [source], fetch}).then(i => i.toArray())\r\n  if (single) {\r\n    return bindings[0].get(\"res\").value\r\n  } else {\r\n    return bindings.map(i => i.get(\"res\").value)\r\n  }\r\n}"],"mappings":"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"}