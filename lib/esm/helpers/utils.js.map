{"version":3,"sources":["../../../src/helpers/utils.ts"],"names":["computeChecksumMd5","file","Promise","resolve","reject","chunkSize","spark","SparkMD5","ArrayBuffer","fileReader","FileReader","cursor","onerror","processChunk","chunk_start","chunk_end","Math","min","size","readAsArrayBuffer","slice","onload","e","append","target","result","end","parseStream","stream","chunks","on","chunk","push","Buffer","from","err","JSON","parse","concat","toString","getQueryResult","source","property","fetch","single","myEngine","q","bindings","query","sources","then","i","get","value","map"],"mappings":"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","sourcesContent":["import * as SparkMD5 from 'spark-md5';\r\nimport { IQueryResultBindings, newEngine } from '@comunica/actor-init-sparql';\r\n\r\nexport function computeChecksumMd5(file: File): Promise<string> {\r\n    return new Promise((resolve, reject) => {\r\n      const chunkSize = 5242880; // Read in chunks of 5MB\r\n      const spark = new SparkMD5.ArrayBuffer();\r\n      const fileReader = new FileReader();\r\n  \r\n      let cursor = 0; // current cursor in file\r\n  \r\n      fileReader.onerror = function(): void {\r\n        reject('MD5 computation failed - error reading the file');\r\n      };\r\n  \r\n      // read chunk starting at `cursor` into memory\r\n      function processChunk(chunk_start: number): void {\r\n        const chunk_end = Math.min(file.size, chunk_start + chunkSize);\r\n        \r\n        fileReader.readAsArrayBuffer(file.slice(chunk_start, chunk_end));\r\n      }\r\n  \r\n      // when it's available in memory, process it\r\n      // If using TS >= 3.6, you can use `FileReaderProgressEvent` type instead \r\n      // of `any` for `e` variable, otherwise stick with `any`\r\n      // See https://github.com/Microsoft/TypeScript/issues/25510\r\n      fileReader.onload = function(e: any): void {\r\n        spark.append(e.target.result); // Accumulate chunk to md5 computation\r\n        cursor += chunkSize; // Move past this chunk\r\n  \r\n        if (cursor < file.size) {\r\n          // Enqueue next chunk to be accumulated\r\n          processChunk(cursor);\r\n        } else {\r\n          // Computation ended, last chunk has been processed. Return as Promise value.\r\n          // This returns the base64 encoded md5 hash, which is what\r\n          // Rails ActiveStorage or cloud services expect\r\n          // resolve(btoa(spark.end(true)));\r\n  \r\n          // If you prefer the hexdigest form (looking like\r\n          // '7cf530335b8547945f1a48880bc421b2'), replace the above line with:\r\n          resolve(spark.end());\r\n        }\r\n      };\r\n  \r\n      processChunk(0);\r\n    });\r\n  }\r\n\r\nexport function parseStream(stream) {\r\n  const chunks = [];\r\n  return new Promise((resolve, reject) => {\r\n    stream.on(\"data\", (chunk) => chunks.push(Buffer.from(chunk)));\r\n    stream.on(\"error\", (err) => reject(err));\r\n    stream.on(\"end\", () =>{\r\n      resolve(JSON.parse(Buffer.concat(chunks).toString(\"utf8\")))\r\n    });\r\n  });\r\n}\r\n\r\nexport async function getQueryResult(source, property, fetch, single: boolean = false) {\r\n  const myEngine = newEngine()\r\n  const q = `SELECT ?res WHERE {<${source}> <${property}> ?res}`\r\n  const bindings = await myEngine.query(q, {sources: [source], fetch}).then((i: IQueryResultBindings) => i.bindings())\r\n  if (single) {\r\n    return bindings[0].get(\"?res\").value\r\n  } else {\r\n    return bindings.map(i => i.get(\"?res\").value)\r\n  }\r\n}"],"file":"utils.js"}