{"version":3,"sources":["../../src/LbdDistribution.ts"],"names":["LbdDistribution","constructor","session","dataset","id","fetch","url","accessService","AccessService","dataService","DataService","lbdService","LBDService","checkExistence","status","method","then","result","get","options","data","getContentType","metadata","DCAT","mediaType","map","i","updateMetadata","query","sparqlUpdate","addAccessUrl","accessUrl","q0","accessURL","create","file","mimetype","makePublic","mime","lookup","error","writeFileToPod","undefined","deleteFile","q","distribution","Distribution","downloadURL","Object","keys","length","key","init","delete","myEngine","sources","q1"],"mappings":"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","sourcesContent":["import AccessService from \"./helpers/access-service\";\nimport DataService from \"./helpers/data-service\";\nimport { newEngine, IQueryResultBindings, ActorInitSparql } from \"@comunica/actor-init-sparql\";\n\nimport LBD from \"./helpers/vocab/lbds\";\nimport { AccessRights, ResourceType } from \"./helpers/BaseDefinitions\";\nimport LBDService from \"./LbdService\";\nimport {extract} from \"./helpers/functions\"\nimport {v4} from \"uuid\"\nimport { DCAT, DCTERMS, RDFS } from \"@inrupt/vocab-common-rdf\";\nimport mime from \"mime-types\"\nimport { Session as BrowserSession } from \"@inrupt/solid-client-authn-browser\";\nimport { Session as NodeSession} from \"@inrupt/solid-client-authn-node\";\nimport LbdDataset from \"./LbdDataset\";\n\nexport default class LbdDistribution {\n  public fetch;\n  public accessService: AccessService;\n  public dataService: DataService;\n  public lbdService: LBDService;\n  public url: string;\n  public data: any;\n\n  private dataset: LbdDataset\n\n  private session:  BrowserSession | NodeSession\n\n  /**\n   * \n   * @param session an (authenticated) Solid session\n   * @param dataset the LbdDataset to which this distribution belongs\n   * @param id (optional) identifier of the distribution (default: GUID)\n   */\n  constructor(session: BrowserSession | NodeSession, dataset, id: string = v4()) {\n    this.dataset = dataset\n    this.fetch = session.fetch;\n    this.url = dataset.url + id\n  \n    this.accessService = new AccessService(session.fetch);\n    this.dataService = new DataService(session.fetch);\n    this.lbdService = new LBDService(session);\n  }\n\n  /**\n   * Check the existence of this distribution\n   */\n  public async checkExistence() {\n    const status = await this.fetch(this.url, {method: \"HEAD\"}).then(result => result.status)\n    if (status === 200) {\n      return true\n    } else {\n      return false\n    }\n  }\n\n  /**\n   * @description Get the distribution's content\n   * @param options Fetch options\n   */\n  public async get(options: object = {}) {\n      this.data = await this.fetch(this.url, options)\n  }\n  \n  /**\n   * @description Get the content type of the distribution\n   * @returns contenttype of the distribution\n   */\n  public getContentType() {\n    const metadata = extract(this.dataset.data, this.url)[DCAT.mediaType].map(i => i[\"@id\"])[0]\n    return metadata\n\n  } \n\n\n  /**\n   * @description Update the metadata of the distribution (i.e. its dataset) with a SPARQL query\n   * @param query the SPARQL update\n   */\n  public async updateMetadata(query) {\n    await this.dataService.sparqlUpdate(this.dataset.url, query)\n  }\n\n  /**\n   * @description Add a new dcat:accessURL to the distribution\n   * @param accessUrl Access URL of the distribution (e.g. for a satellite service)\n   */\n  public async addAccessUrl(accessUrl) {\n    const q0 = `INSERT DATA {<${this.url}> <${DCAT.accessURL}> <${accessUrl}>}`\n    await this.updateMetadata(q0)\n  }\n\n  /**\n   * @description Create this distribution on a Pod\n   * @param file The file/content of the distribution\n   * @param options Additional metadata to add to the distribution. form:  {[predicate]: value}\n   * @param mimetype optional: the content type of the distribution. If not provided, it will be guessed. If the guess fails, the content type will be text/plain\n   * @param makePublic access rights\n   */\n  public async create(\n    file: File | Buffer,\n    options: object = {},\n    mimetype?: string,\n    makePublic?: boolean,\n  ) {\n      if (!mimetype) {\n          try {\n              mimetype = mime.lookup(file[\"name\"])\n              if (!mimetype) mimetype = \"text/plain\"\n          } catch (error) {\n              mimetype = \"text/plain\"\n          }\n      }\n          \n    await this.dataService.writeFileToPod(file, this.url, makePublic, mimetype)\n      //workaround to allow inherited access rights\n      if (makePublic === undefined) {\n        this.dataService.deleteFile(this.url + \".acl\")\n      }\n\n      const q = `INSERT DATA {\n        <${this.dataset.url}> <${DCAT.distribution}> <${this.url}> .\n        <${this.url}> a <${DCAT.Distribution}> ;\n            <${DCAT.mediaType}> <https://www.iana.org/assignments/media-types/${mimetype}> ;\n            <${DCAT.downloadURL}> <${this.url}> .\n      }`\n      await this.dataService.sparqlUpdate(this.dataset.url, q)\n    if (Object.keys(options).length > 0) {\n        let q0 = `INSERT DATA { `\n        for (const key of Object.keys(options)) {\n          q0 += `<${this.dataset.url}> <${key}> \"${options[key]}\" .`\n        }    \n        q0 += \"}\"\n        await this.dataService.sparqlUpdate(this.dataset.url, q0)\n      }\n\n    this.dataset.init()\n  }\n\n  /**\n   * Delete this distribution\n   */\n  public async delete() {\n    const myEngine = newEngine()\n    await this.dataService.deleteFile(this.url)\n    // also update dataset\n    const q0 = `DELETE {\n      <${this.url}> ?p ?o .\n    } WHERE {\n      <${this.url}> ?p ?o .\n    }`\n    await myEngine.query(q0, {sources: [this.dataset.url], fetch: this.fetch})\n\n    const q1 = `DELETE {\n      ?s ?p <${this.url}> .\n    } WHERE {\n      ?s ?p <${this.url}> .\n    }`\n    await myEngine.query(q1, {sources: [this.dataset.url], fetch: this.fetch})\n\n    return\n  }\n}\n\n"],"file":"LbdDistribution.js"}